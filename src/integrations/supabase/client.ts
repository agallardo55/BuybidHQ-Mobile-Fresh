// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { logger } from '@/utils/logger';

logger.debug('üîç Supabase client: Module loaded, imports completed');

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

logger.debug('üîç Supabase client: Environment variables checked', { 
  hasUrl: !!SUPABASE_URL, 
  hasKey: !!SUPABASE_PUBLISHABLE_KEY 
});

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

logger.debug('üîç Supabase client: Creating client instance...');

// Wrap client creation in try-catch to prevent blocking on errors
let supabase: ReturnType<typeof createClient<Database>>;

if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  const error = new Error('Missing Supabase environment variables. Please check your .env file.');
  logger.error('‚ùå Supabase client: Configuration error', error);
  logger.error('‚ùå Supabase client: SUPABASE_URL:', SUPABASE_URL ? 'present' : 'MISSING');
  logger.error('‚ùå Supabase client: SUPABASE_PUBLISHABLE_KEY:', SUPABASE_PUBLISHABLE_KEY ? 'present' : 'MISSING');
  // Don't throw - create a dummy client to prevent blocking
  // The app will show errors when trying to use Supabase, but at least it will load
  logger.warn('‚ö†Ô∏è Supabase client: Creating dummy client to prevent blocking');
  supabase = createClient<Database>('https://dummy.supabase.co', 'dummy-key', {
    auth: { persistSession: false, autoRefreshToken: false }
  }) as any;
  logger.warn('‚ö†Ô∏è Supabase client: Dummy client created - Supabase features will not work');
} else {
  try {
    supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        },
        storage: {
          getItem: (key) => {
            try {
              return localStorage.getItem(key)
            } catch (e) {
              logger.warn('Supabase client: localStorage.getItem failed', e);
              return null
            }
          },
          setItem: (key, value) => {
            try {
              localStorage.setItem(key, value)
            } catch (e) {
              logger.warn('Supabase client: localStorage.setItem failed', e);
            }
          },
          removeItem: (key) => {
            try {
              localStorage.removeItem(key)
            } catch (e) {
              logger.warn('Supabase client: localStorage.removeItem failed', e);
            }
          },
        },
      },
      db: {
        schema: 'public'
      },
      global: {
        headers: {
          'apikey': SUPABASE_PUBLISHABLE_KEY,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        },
      },
    });

    logger.debug('‚úÖ Supabase client: Client instance created');
  } catch (error) {
    logger.error('‚ùå Supabase client: Failed to create client', error);
    // Don't throw - create a dummy client to prevent blocking
    logger.warn('‚ö†Ô∏è Supabase client: Creating dummy client after error');
    supabase = createClient<Database>('https://dummy.supabase.co', 'dummy-key', {
      auth: { persistSession: false, autoRefreshToken: false }
    }) as any;
  }
}

export { supabase };

// REMOVED: onAuthStateChange listener at module level
// This was causing duplicate listeners and potential race conditions.
// AuthContext.tsx already handles all auth state changes properly.
// If you need to clear localStorage on sign out, do it in AuthContext.

logger.debug('‚úÖ Supabase client: Module initialization complete');

// REMOVED: clearInvalidSession() call at module load
// Even with timeout, calling getSession() at module initialization can block the app
// if getSession() hangs before returning a promise. This prevents React from even starting.
//
// Session validation is handled safely in AuthContext.tsx useEffect instead,
// which runs after React mounts and can properly handle timeouts and errors.
//
// If you need to clear invalid sessions, do it in AuthContext or after app initialization.